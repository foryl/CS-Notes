<!-- GFM-TOC -->
<!-- GFM-TOC -->


- [Twitter Java Style Guide](https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/styleguide.md)
- [Google Java Style Guide](http://google.github.io/styleguide/javaguide.html)


# 0. 前言
## 0.1 范围
本规范自发布之日生效，新编写和修改涉及的代码必须遵守本规范。

## 0.2 原则
### 原则 0.1 代码要“易读”
代码以清晰第一，简洁为美。
能被快速读懂的代码才是好代码。

### 原则 0.2 代码要“易改”
在代码易读懂的前提下，需要考虑代码维护、扩展的代价。
产品代码需要考虑热补丁可行性。

## 0.3 老代码
在修改不符合编程规范的老代码时，在精力允许的前提下，推荐小范围整改重构，以符合编程规范。
但不推荐大批量整改编程规范问题。

一个文件内允许新老共存；但同一个函数或表内部必须风格统一。

### 规则 0.1 同一个函数或同一个表内部，编程风格必须保持一致

### 建议 0.1 推荐在修改代码时对不符合编程规范的代码进行小范围重构

鼓励小范围重构代码，哪怕只是简单的对齐。积少成多！

## 0.4 静态检查

在处理静态检查错误或告警时，必须遵循`原则 0.1`、`原则 0.2`
即，不能为了静态检查不报错，而将代码改“坏”掉。
在明白报错机理的前提下，可适当屏蔽！

# 1. 排版

## 1.1 缩进

### 规则 1.1 程序块采用缩进风格编写，每级缩进为4个空格；禁止使用TAB键
例:
```lua
function add(a, b)
    return a + b -- 前面 4 个空格
end
```
### 规则 1.2 禁止不同类的短语句写在同一行；尽量一行只写一个语句

可以接受的排版:
```lua
local a, b
a = 100; b = 200 -- 同类，可以写在同一行
```

比较好的写法：
```lua
-- Good!
local a = 100
local b = 200
```

或者
```lua
-- Good!
local a, b = 100, 200
```

不同类的语句不要写在同一行，如
```lua
-- Bad!
local a = 100; print(a)
```

### 规则 1.3 对于 if..then/while..do/for..do 及表定义时，对应关键字或括号写在行末
例:
```lua
local tom = {     -- 左大括号留在行末
    name = 'Tom',
    age  = '10'
}
```
```lua
if error then     -- 关键字 then 留在行末
    return -1
end
```
```lua
while true do     -- 关键字 do 留在行末
    loop()
end
```
```lua
for k, v in pairs(t) do -- 关键字 do 留在行末
    print(k, v)
end
```

### 建议 1.1 对于简单的 if/while/repeat/for/function 语句，可以写在一行内
例:
```lua
if error then return end
```
```lua
local add = function(a, b) return a + b end
```

## 1.2 空格，空行

### 规则 1.4 运算符两边必须加空格；'#'(取长度), '.'(取成员), ':'(对象调用) 用紧跟模式

### 规则 1.5 逗号(,)，分号(;)的使用符合英文习惯，即紧跟前方，后跟 1 空格

### 规则 1.6 小括号，中括号内部两端无空格，作为函数调用，按键取值时，紧跟前方无空格

### 规则 1.7 大括号内容复杂时，内部两端需要 1 空格，或另起一行缩进一层

两种构造表的写法，注意空格的使用：
```lua
local t1 = { 100, 200 }
local t2 = {
    100,
    200
}
```
空格的使用:
```lua
local t = { 100, 200, 300 }
local sum = t[1] + t[2] + t[3]
local fmt = 'sum = %d, cnt = %d'
local msg = fmt:format(sum, #t)
local empty = {} -- 无内容空表，括号内部无需空格
```

### 规则 1.8 注释符与注释内容间至少有 1 空格
```lua
-- 这是单行注释

--[[ 这是多行注释
     这是第二行 ]]

-- 这是另一种多行注释
-- 这是第二行
```

### 规则 1.9 逻辑不连续的代码段之间，增加空行

至于增加 1 行还是 2 行，由代码段之间相关性决定；
尽量做到整个模块空行的使用标准统一

# 1.3 布局

### 规则 1.10 文件长度不超过 2000 行，函数长度不超过 50 行；或者以版本规定为准

文件/模块，函数均不宜过长，否则应该考虑进一步分层、抽象。

### 建议 1.2 一行代码，最多不超过 100 个字符；或者以版本规定为准

一行代码不宜过长；
以常见编辑器为例，要保证重要信息在不拉动滚动条的前提下全部可见

### 规则 1.11 当一行语句需要换行时，相关连接符放在行末，同类缩进对齐

当复杂表达式，或者比较长的函数调用语句、或者长注释、长字符串，需要分多行写时
应如：

```lua
if t.x == 100 and  -- 'and' 逻辑运算符放在行末
   t.y == 200 then -- 此处换行 't' 与上一行 't' 对齐
    do_sth(t)
end
```
```lua
foo(data1,
    data2, -- 此处换行，'data2' 与上一行 'data1'对齐
    data3)
```
```lua
value = a + b + c + d +     -- 运算符 '+' 放在行末
        e + f + g + h       -- 此处换行，同类对齐
```
```lua
-- 长字符串举例
local msg = 'Lua is a powerful, efficient, lightweight, embeddable scripting ' ..
            'language. It supports procedural programming, object-oriented ' ..
            'programming, functional programming, data-driven programming, ' ..
            'and data description.'
```
```lua
do_sth()    -- 这是注释，可能注释内容比较多
            -- 所以这里另起一行；注意前方 '--' 与上一行对齐
do_other()
```
`注意: 当一行语句过长时，首先应该考虑是否可以优化代码`
比如：
- 是否函数名过长？
- 是否函数参数过多？参数是否全部必需？是否可包装成表？
- 是否表达式过于复杂？表达式逻辑是否可以抽象成函数？

### 建议 1.3 并列类似语句，考虑同类缩进对齐，或运算符、操作符对齐
例：
```lua
tom.name = 'Tom'
tom.age  = 10       -- 此处等号保持与上一行对齐
```
```lua
local t = {
    { name = 'Tom',   age = 10 }  -- 此处 'age' 特意与下一行 'age' 对齐
    { name = 'Jerry', age = 11 }
}
```

### 规则 1.12 if/while/until 后面的条件表达式最外层不要加括号
不同于C语言，这里加括号多余。例：
```lua
-- Bad!
while (next) do                   -- 括号多余
    if (next.value > MAX) then    -- 括号多余
        -- ...
    end
    -- ...
end
```
```lua
-- Good!
while next do
    if next.value > MAX then
        -- ...
    end
    -- ...
end
```

# 2 命名

### 原则 2.1 符号命名要简洁，准确

命名包括模块、文件、函数、变量等所有符号的命名
符号命名要能恰恰好概括其内容，不多，不少

如果发现命名困难时，请考虑：
- 设计是否合理？
- 功能是否单一？是否可拆分？
- 是否多余？
- 英文不行？

### 规则 2.1 命名风格使用 snake_case

snake_case，即 lower_case_with_underscores，即用下划线来分割多个全小写单词

当表示常量时，用全大写，下划线分割单词

参考 <https://en.wikipedia.org/wiki/Snake_case>

例：

```lua
local DEFAULT_PORT = 8080     -- 常量

local some_net_func = function(ip, port)
    port = port or DEFAULT_PORT
    -- ...
end
```

`注意：下划线开头的全大写符号为 Lua 保留，不得使用`

如 \_G, \_VERSION 为 Lua 保留

`注意：符号命名不能使用 arg`

变量 arg 作为执行参数，为 Lua 保留

### 规则 2.2 禁止使用魔鬼数字

所谓魔鬼数字，即看不懂的数字，视其看不懂的程度，有轻重之分。
换位思考，如果读代码的人看到这个数字，无法从上下文中很快的了解这个数字取该值的原因，
那么这个数字就是魔鬼数字。

解决魔鬼数字的方法有两种：
- 如果多处使用，为方便维护，建议用变量（常量）替换，并尽量通过其命名自注释
- 如果仅仅是一处使用，也可以通过注释来说明其取值的原因

处理数字或魔鬼数字的原则就是：不要浪费读者时间

### 建议 2.1 给布尔变量或返回布尔值的函数命名时，要尽量贴近英文语法

贴近英文语法，使代码更容易阅读，例：
```lua
-- Bad!
if is_found then ... end
```

```lua
-- Good!
if found then ... end
```

仔细体会下面代码中的 'is_directory' 和 'directory'：
```lua
local is_directory = file_or_dir(path)
if is_directory then ... end    -- 命名OK，判断路径是文件还是目录

local directory = get_some_dir(...)
if directory then ... end       -- 命名OK，判断目录是否存在
```


### 规则 2.3 模块内部变量或表成员变量命名时，禁止包含冗余的前缀

通过模块或表访问其内部变量（包括函数）时，已经知道模块或表信息了
在没有二义性的前提下，其内部变量应尽量简洁

比如下面的某模块代码：
```lua
-- Bad!
-- my_module.lua
module('my_module', package.seeall)

function my_module_foo() ... end        -- 对外接口，模块前缀冗余！
local function my_module_bar() ... end  -- 内部函数，同样冗余！
```

其他模块调用其接口时，则是这样：
```lua
require('my_module')
my_module.my_module_foo()               -- 不简洁！
```


正确的做法是：
```lua
-- Good!
-- my_module.lua
module('my_module', package.seeall)

function foo() ... end                  -- 对外接口
local function bar() ... end            -- 内部函数
```

此时其他模块访问起来是这样子：
```lua
require('my_module')
my_module.foo()                         -- 简洁。
```

表成员的命名也一样，下面的做法显然不妥：
```lua
-- Bad!
local tom = {
    tom_name = 'Tom',                   -- 表前缀冗余！
    tom_age  = 10
}
```

### 建议 2.2 局部变量在不影响阅读理解的前提下，尽量短小

局部变量的特征是生命周期短，临时使用
即使其命名未准确表达其完整含义，但配合上下文信息，也很容易被理解

例：
```lua
-- Not good!
local function print_xxx_help_msg(...)
    local xxx_help_msg = '...'          -- 完整表达，但较长
    -- ...
end
```

```lua
-- Good!
local function print_xxx_help_msg(...)
    local msg = '...'                   -- 简洁，容易理解
    -- ...
end
```

# 3 注释

### 原则 3.1 注释是为了辅助代码被读懂，是为了节省读代码、改代码的时间成本

注释存在的唯一目的就是让代码更容易被读懂
写代码时，在可预见代码理解困难的地方，加上`给力`注释
废话式注释，对代码理解无帮助，浪费读者时间，消耗维护成本

写注释时，应换位思考，用心写；想方设法去节省读代码人的时间

### 规则 3.1 禁止为了注释率去增加注释

清晰的架构，简洁的排版，准确的命名，这种代码读起来很容易懂。
没必要为了注释率批标，再去加一堆“废话”式注释

### 原则 3.2 注释中的中英文语法要正确，语义明确，无二义性

努力提高自己英文水平，不要盲目自信。

### 规则 3.2 禁止 'add by xxx' 类注释，禁止简单的参考式注释

代码不需要呈现其演变历史过程，只需要呈现其最终的状态
注释也应该是针对最终代码的注释

参考式注释，比如下面这种：
```lua
-- 具体参见 DTS00000012345
-- ...
```
只简单写一个问题单号，让读者去查阅、理解；
极其浪费时间，还不一定找得到要点

正确的做法是，将要点提取出来，直接呈现给读者
浪费一次写代码人的时间，但更多的读代码人的时间被节省了

### 规则 3.3 禁止无信息量的文件头，函数头注释

代码首要原则是“易读”，无信息量的注释不简洁，干扰了阅读，还消耗维护成本
如下面这种，可能是按版本要求，加了统一的函数头，但没有用心填写，不如不写：
```lua
-- Func Name       : foo
-- Date Created    : 2017-06-23
-- Author          : Megatron
-- Description     :
-- Input           :
-- Output          :
-- Return          :
-- Caution         :
------------------------------------------------------------------------
function foo(...)
    -- ...
end
```

### 规则 3.4 修改代码时，与之相关的注释信息需要同步修改

注释与代码对应不上，让人费解甚至误导别人

### 规则 3.5 注释应该放在对应代码的上方或右方，不得放代码下方
### 规则 3.6 代码上方的注释应该与代码对齐；代码后方的注释如有多行同类，应对齐
如：
```lua
-- 这是函数 foo 的注释，放在其上方
function foo(a)
    -- ...
end
```
下例，注释1与注释2应对齐
```lua
t = {
    name = 'Tom',   -- 注释1
    age  = 10       -- 注释2
}
```

# 4 语句

## 4.1 表

### 规则 4.1 禁止对不连续的数组表求长度

对不连续数组求长度时，结果不可预测。
例：
```lua
local t = { 1, 2, 3, 4 }
t[2] = nil
print(#t) -- 此处打印是 4，而不是预想的 1 或 3
```

### 建议 4.1 表内的函数成员，建议在表外定义
```lua
-- Bad!
local tom = {
    name = 'Tom',
    age  = 10,
    run  = function()
        -- ...
    end
}
```
```lua
-- Good!
local tom = {
    name = 'Tom',
    age  = 10
}
tom.run = function()
    -- ...
end
```

### 建议 4.2 表内已知成员，用 '.' 访问，而不是 '[...]'
如：
```lua
local tom = {
    name = 'Tom',
    -- ...
}

print(tom.['name']) -- Bad!
print(tom.name)     -- Good!
```

## 4.2 字符串

### 规则 4.2 使用单引号(')来引用字符串，多行可以使用双中括号([[/]])

不要使用双引号(")来引用字符串；
原因：单引号更环保。

例：
```lua
-- Bad!
local msg = "Hello, World!"
```
```lua
-- Good!
local msg = 'Hello, World!'
```

在某些情况下，比如多行回显，使用双中括号更直观些，例：
```lua
-- Good!
local msg = [[
This is 1st line.
This is 2nd line.]]
```

## 4.3 变量

### 原则 4.1 变量要做到 “读前必被写，写后必被读”

- “读前必被写”：指读取变量时，一定是之前被有效赋值过的
  例：
```lua
-- Bad!
function foo()
    local value
    if ... then
        value = get_xx_value()
    end
    return value    -- 若 if 不成立，则 ret 就未被有效赋值
end
```
```lua
-- Good!
function foo()
    local value = DEFAULT_VALUE   -- 默认值
    if ... then
        value = get_xx_value()
    end
    return value
end
```
- “写后必被读”：指对变量写入值后，后面一定有人来读取
  例：
```lua
-- Bad!
function foo()
    local value

    -- 一些使用了 value 的代码

    value = nil     -- 这里赋 nil 完全多余！应删除掉
    return
end
```

### 规则 4.3 不要拿布尔变量再去与 true/false 比较

此规则，适用 if/while/until 中的布尔表达式
例：
```lua
-- Bad!
if found == true then ... end
```
```lua
-- Good!
if found then ... end
```

### 建议 4.3 占位符变量('\_')后面需要跟有其他变量

例：
```lua
-- Bad!
_ = f1()
_, b, _ = f2()
```
```lua
-- Good!
f1()          -- 直接忽略返回值
_, b = f2()   -- 只需要 1 个占位符变量
```

## 4.4 其他语句

### 规则 4.4 禁止循环体内修改循环变量

因为修改了，也是无效修改
如下例中的循环，试图循环从5直接跳到9；而实际仍然是循环了 10 次！
```lua
for i = 1, 10 do
    -- ...
    if i == 5 then i = 9 end  -- 从 5 直接跳到 9
end
```

### 规则 4.5 比较时常量放右；更符合阅读习惯

不同于 C 语言，下面这种写法 Lua 会报语法错误
```lua
if a = 100 then ... end   -- Error! 语法错误
```

变量与常量比较时，把常量写后面，更符合“易读”原则
```lua
if 100 == a then ... end  -- Bad!

if a == 100 then ... end  -- Good!
```

# 5 函数

### 原则 5.1 函数尽量短小

短的读起来轻松，心智消耗最少。
人脑短时记忆量有限，我们要让读代码的人不用滑动鼠标滚轮就可以阅读整个函数。
好的代码能引领读者一层一层进入，理解起来不会让读者感觉疲惫。

`函数，可以避免重复代码；更重要的作用是分层！`

### 规则 5.1 函数内部临时变量，按需定义，按需初始化
按需定义的意思是，在需要使用时才定义，不要全部集中在函数头部。
例：
```lua
-- Bad!
function foo(...)
    local ok            -- 定义在开头
    -- ...
    ok = do_sth(...)    -- 使用与定义相隔太远
    -- ...
end
```
按需初始化的意思是，不做无意义的赋值
例：
```lua
-- Bad!
function foo(...)
    local ok = nil      -- 此处赋nil无意义，local ok 天生就是 nil;
                        -- 而且此处赋任何值都会被下面覆盖
    -- ...
    ok = do_sth(...)
    -- ...
end
```
正确的做法是：
```lua
-- Good!
function foo(...)
    -- ...
    local ok = do_sth(...)    -- 需要时，直接定义
    -- ..
end
```


### 原则 5.2 函数尽可能少的读写外部变量，包括全局变量；可以考虑闭包

函数如果读写了外部变量，其行为即与外部环境有了隐藏的耦合.

所以设计代码时尽量不使用；即使要使用，对变量的读写应该集中封装起来

例：
```lua
-- 这里用一个模块内部 local 的变量来计数
local count = 0

-- 对 count 的读写，用下面两个函数封装起来
local function add_count(a) count = count + a end
local function get_count() return count end
```
上述代码，更好的做法是用闭包实现对 count 的隐藏，保证其读写的集中、安全
如下：
```lua
local function get_counter()
    local count = 0
    counter = {}
    counter.add = function(a) count = count + a end
    counter.get = function() return count end
    return counter
end

-- 使用
local counter = get_counter()
counter.add(1)
print(counter.get())
```

### 原则 5.3 合理规划模块中的调试、日志代码；函数中的调试、日志部分尽量少，不可以喧宾夺主

一个模块尽量只在出入口或异常时记录调试、日志信息，其中间行为过程尽量通过UT去保证可靠性

另外，可以通过函数，把读者不需要关心的细节封装起来，例：
```lua
local local_debug(...)
    xxx_debug(level = 'debug', module = CURRENT_MODULE, ...)
end
```

### 规则 5.2 当表的成员函数引用表时，命名用 self

在如下面向对象编程中，使用 self 来引用表本身。
例：
```lua
local tom = {
    name = 'Tom',
}
tom.say_hi = function(self)
    print('Hi, I am ' .. self.name)
end

-- 使用时
tom:say_hi()
```

### 建议 5.1 多返回值函数参与多值赋值，或直接作为函数参数时，需谨慎使用

如下代码，可能并非代码本意：
```lua
local function foo() return 1, 2, 3 end
print(10, foo(), 20, foo())   -- 实际输出 10  1  20  1  2  3

local a, b, c, d = f(), 4
print(a, b, c, d)             -- 实际输出 1  4  nil  nil
```

# 6 模块
### 原则 6.1 模块功能接口清晰；遵循最少知道原则

一个 Lua 文件（模块）对外提供哪些可用接口，必须清晰明了；
通常有 2 种方法导出接口：

####方法 1：用 module/package.seeall 修饰 Lua 文件（模块）
其他文件 require 该文件时，实际上是注入了一个名字是模块名的全局表，
该表包含了其所有非 local 符号，即对外接口
所以，写代码时，不对外的变量（包括函数），必须用 local 修饰，保持外部不可见

例：
```lua
-- a.lua
module('a', package.seeall)
function foo() ... end        -- 对外接口
local function bar() ... end  -- 私有，外部不可见
```
```lua
-- b.lua
require('a')
a.foo()                       -- 调用 a.lua 中非 local 接口
```

`注意：当前热补丁就是通过替换该模块对应全局表变量来实现的`

####方法 2：在文件（模块）最后，将对外接口 return 给 require 函数
这种方法通过获取 require 该文件时的返回值，来获取该模块所有对外接口
此时，文件中所有变量（包括函数）均应该用 local 修饰，
即除了返回值，外部不关心其内部细节

例：
```lua
-- a.lua
local M = {}
function M.foo() ... end     -- 对外接口
local function bar() ... end -- 私有，外部不可见
return M                     -- 返回给 require 函数
```
```lua
-- b.lua
local a = require('a')        -- 得到 'a.lua' 中返回的接口
a.foo()
```

`注意：上述方法 2 因为没有生成全局变量，所以不能通过替换全局变量来打热补丁`

### 规则 6.1 不得长时间记忆保存其他模块的导出接口，否则补丁失效

此规则适用于 'module/package.seeall' 描述的模块，及对应替换全局接口表的补丁方案

假如有如下模块 'module_a'：
```lua
module('modul_a', package.seeall)
function foo(...) ... end     -- 对外接口 foo
```

当其他模块引用上述模块时
```lua
module('module_b', package.seeall)
require('module_a')

local a = module_a            -- 长时间记忆了 module_a
local foo = module_a.foo      -- 长时间记忆了 module_a.foo

local bar(...)
    a.foo(...)                -- 在使用记忆中的 module_a.foo，后续补丁无效
    foo(...)                  -- 在使用记忆中的 module_a.foo，后续补丁无效
    -- ...
end
```

正确的做法是始终通过全局变量 'module_a' 表去访问该模块的接口
```lua
module('module_b', package.seeall)
require('module_a')

local bar(...)
    module_a.foo(...)
end
```

或者，短时间记忆是允许的
```lua
module('module_b', package.seeall)
require('module_a')

local bar(...)
    local foo = module_a.foo  -- 记忆仅在函数 bar 作用域内有效

    foo(...)
    -- ...
    foo(...)                  -- 多次调用 foo 时，这种方法更简洁
end
```

### 建议 6.1 Lua 文件（模块）中，对外接口尽量放文件开头；不对外变量（包括函数）放下面

新手拿到一份代码，最怕的就是无从下手。
我们希望不用借助比如 source insight 的函数跳转功能，从上至下阅读逐个函数，就能快速读懂代码。
一个文件要首先实现对外呈现的接口，再到内部适配、内部实现；这样更方便读者读懂代码

### 原则 6.2 设计模块接口时，遵循单一职责原则

即，一个接口只做一件事，例：
```lua
-- Bad!
funtion open_or_close_file(file, is_open) ...  end

-- Good
funtion open_file(file) ... end
funtion close_file(file) ... end
```
### 原则 6.3 模块间依赖关系明确，架构清晰；禁止间接依赖

所谓间接依赖，比如 A require B，B require C，A 没有直接 require C 却能使用 C 接口；
语法上间接依赖是没有问题，但架构上却很不清晰！

### 规则 6.2 禁止循环依赖，禁止依赖(require)不需要的模块

如发产生循环依赖，请重新设计架构

# 7 其他
